/*	===================== _reFlow ===================== 	An underflow has occurred in a subtree to root. 	Correct by balancing or concatenating. 	   Pre    root is pointer to underflow tree/subtree	          entryNdx is parent of underflow subtree	   Post   Underflow corrected	   Return underflow true / false */bool _reFlow  (NODE* root, int entryNdx){//	Local Definitions 	NODE* leftTreePtr;	NODE* rightTreePtr;	bool  underflow;	//	Statements 	if (entryNdx == 0)	   leftTreePtr = root->firstPtr;	else	   leftTreePtr = root->entries[entryNdx - 1].rightPtr;	rightTreePtr   = root->entries[entryNdx].rightPtr;	// Try to borrow first 	if (rightTreePtr->numEntries > MIN_ENTRIES)	       {	        _borrowRight (root,        entryNdx, 	                      leftTreePtr, rightTreePtr);	        underflow   = false;	       } // if borrow right 	else	   {	    // Can't borrow from right--try left 	    if (leftTreePtr->numEntries > MIN_ENTRIES)	       {	        _borrowLeft (root,        entryNdx,	                     leftTreePtr, rightTreePtr);	        underflow  = false;	       } // if borrow left *	   else	       {	        // Can't borrow. Must combine nodes. 	       _combine (root,        entryNdx, 	                 leftTreePtr, rightTreePtr);	        underflow = (root->numEntries < MIN_ENTRIES);	       } // else combine 	   } // else borrow right 	return underflow;}	// _reFlow 