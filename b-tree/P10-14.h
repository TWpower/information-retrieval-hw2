/*	==================== _combine ==================== 	Underflow cannot be corrected by borrowing. 	Combine two subtrees.	   Pre  root contains parent to underflow node	        entryNdx is parent entry	        leftTreePtr & rightTreePtr are subtree ptrs	   Post Parent & subtrees combined-right node freed*/void _combine (NODE* root,        int   entryNdx,                NODE* leftTreePtr, NODE* rightTreePtr){//	Local Definitions 	int toNdx;	int fromNdx;	int shifter;	//	Statements 	// Move parent & set its right pointer from right tree 	toNdx = leftTreePtr->numEntries;	leftTreePtr->entries[toNdx].dataPtr 	        = root->entries[entryNdx].dataPtr;	leftTreePtr->entries[toNdx].rightPtr 	        = rightTreePtr->firstPtr;	++leftTreePtr->numEntries;	--root->numEntries;		// move data from right tree to left tree 	fromNdx = 0;	toNdx++;	while (fromNdx < rightTreePtr->numEntries)	    leftTreePtr->entries[toNdx++] 	         = rightTreePtr->entries[fromNdx++];	leftTreePtr->numEntries += rightTreePtr->numEntries;	free (rightTreePtr);		// Now shift data in root to the left 	shifter = entryNdx;	while (shifter < root->numEntries)	   {	    root->entries[shifter] = 	          root->entries[shifter + 1];	    shifter++;	   } // while 	return;}	// _combine 