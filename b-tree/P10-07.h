/*	==================== _insert ===================	This function uses recursion to insert the new data  	into a leaf node in the B-Tree.	   Pre    Application has called BTree_Insert,   	             which passes root and data pointers	   Post   Data have been inserted	   Return taller boolean*/bool _insert (BTREE* tree,      NODE*  root,              void*  dataInPtr, ENTRY* upEntry){//	Local Declarations 	int  compResult;	int  entryNdx;	bool taller;		NODE* subtreePtr;	//	Statements 	if (!root)	   {	    // Leaf found -- build new entry 	    (*upEntry).dataPtr  = dataInPtr;	    (*upEntry).rightPtr = NULL;	    return true;                   // tree taller 	   } // if NULL tree 		entryNdx   = _searchNode (tree, root, dataInPtr);	compResult = tree->compare(dataInPtr, 	                  root->entries[entryNdx].dataPtr);	if (entryNdx <= 0 && compResult < 0)	    // in node's first subtree 	    subtreePtr = root->firstPtr;	else	    // in entry's right subtree 	    subtreePtr = root->entries[entryNdx].rightPtr;	taller = _insert (tree,      subtreePtr, 	                  dataInPtr, upEntry);	// Entry inserted -- back out of tree 	if (taller)	   {	    if (root->numEntries >= ORDER - 1)	       {	        // Need to create new node 	        _splitNode (root,       entryNdx, 	                    compResult, upEntry);	        taller = true;	       } // node full 	    else	       {	        if (compResult >= 0)	           // New data >= current entry -- insert after	            _insertEntry(root, entryNdx + 1, *upEntry);	        else	           // Insert before current entry 	            _insertEntry(root, entryNdx, *upEntry);	        (root->numEntries)++;	        taller = false;	       } // else 	   } // if taller 	   	return taller;}	// _insert 