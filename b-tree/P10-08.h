/*	=================== _splitNode =================== 	Splits node when node is full.	   Pre  node has overflowed--Split node 	        entryNdx is index location for new data	        compResult new data < or > entryNdx key	        upEntry pointer to data to be inserted	   Post node split and upEntry contains entry to	           be inserted into parent	    or- Program aborted if memory overflow*/void _splitNode  (NODE* node,       int    entryNdx,                  int   compResult, ENTRY* upEntry)                  {//	Local Definitions 	int   fromNdx;	int   toNdx;	NODE* rightPtr;	//	Statements 	rightPtr  = (NODE*)malloc(sizeof (NODE));	if (!rightPtr)	   printf("Overflow Error 101 in _splitNode\a\n"), 	           exit (100);	// Build right subtree node 	if (entryNdx < MIN_ENTRIES)	    fromNdx  = MIN_ENTRIES;	else	    fromNdx  = MIN_ENTRIES + 1;	toNdx = 0;	rightPtr->numEntries = node->numEntries - fromNdx;	while (fromNdx < node->numEntries)	    rightPtr->entries[toNdx++]	                = node->entries[fromNdx++];	node->numEntries = node->numEntries 	                   - rightPtr->numEntries;		// Insert new entry 	if (entryNdx < MIN_ENTRIES)	   {	    if (compResult < 0)	        _insertEntry (node, entryNdx, *upEntry);	    else	        _insertEntry (node, entryNdx + 1, *upEntry);	   } // if 	else	   {	    _insertEntry (rightPtr, 	                 entryNdx - MIN_ENTRIES, 	                 *upEntry);	    (rightPtr->numEntries)++;	    (node->numEntries)--;	   } // else 	upEntry->dataPtr   = node->entries[MIN_ENTRIES].dataPtr;	upEntry->rightPtr  = rightPtr;	rightPtr->firstPtr 	              = node->entries[MIN_ENTRIES].rightPtr;		return;}	// _splitNode 